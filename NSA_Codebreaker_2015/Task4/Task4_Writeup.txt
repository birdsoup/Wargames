Challenge:
A military organization has inquired as to whether it would be possible to spoof messages to the terrorists, making the messages appear to come from the terror group's leadership. This capability would be a game-changer in their efforts to disrupt and disband the organization. Program binaries and keys have already been distributed throughout the terrorist organization, though, so achieving this effect must be done only by modifying the message file. Your mission is to investigate whether this is possible and, if so, provide a message file that would spoof the following message while making it appear as though it came from the leadership. The message will be sent to the same high-ranking member that the message from Task 1 was originally sent to.

The message to encode is, "SENSITIVE MESSAGE: Leadership has arranged a meeting with the local authorities to discuss partnering opportunities. As a high-ranking member in our organization, your attendance is requested. Meet at the city police station at 18:00. Be discreet, and come unarmed as to not draw attention. Mention the pass code qaa1nxhcre48wp1v553j at the front desk to be escorted in.". Use the template file from Task 3 to encode this message into.

------------------------------------------------------------------------------------------------------------------------------------------

This challenge was pretty easy. At first I thought that there was some way to cheat RSA_verify to return true even with a bad signature, but as far as I know, there is no such way. However, by looking at the decompiled code, I noticed that the branch that is taken to the VALID code does not check the return of RSA_verify. Rather, it ANDS the return of RSA_verify with some magic number, stores it somewhere, then later checks that value to decide whether or not to branch. So what if there were some way to modify that value after its between stored and before its being checked again?

Looking at the code further reveals two interesting operations, memcpy and __memcpy_chk. Memcpy seemed to just be copying the message somewhere to print later. However, the destination for memcpy_chk seemed to be within of where the magic number is being stored. Interestingly, it takes 0x84 as an argument; however the buffer associated with it is the message signature, which is only 0x80 bytes. And bytes 80-84 seems to be exactly where the magic number was being stored. So at this point it was obvious what I had to do. I appended that magic number to my signature and passed that in as the message and HOORAY it worked. I had to change the headers to account for the larger text and signature. The signature, in addition, does not have to be anything in particular since it doesn't matter if its correct or not anymore. I still had to Base64Encode it first before, though.

Time estimate: 3 hrs